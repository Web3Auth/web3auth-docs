---
title: "Client-Side Setup for Telegram Mini App with Web3Auth"
image: "guides-banners/telegram-miniapp-client.png"
description: |
  Learn how to set up the client-side of a Telegram Mini App using Web3Auth Web SDK to authenticate users and retrieve wallet details. This guide is the second part of the Telegram Mini App series.
type: guide
tags: [client, telegram, authentication, web3auth, ton, web-sdk]
date: October 24, 2024
author: Web3Auth Team
---

import SEO from "@site/src/components/SEO";
import TelegramMiniAppDiagram from "@site/static/images/telegram-mini-app-flow-diagram.png";

<SEO
  title="Client-Side Setup for Telegram Mini App with Web3Auth"
  description="Learn how to set up the client-side of a Telegram Mini App using Web3Auth Web SDK to authenticate users and retrieve wallet details."
  image="https://web3auth.io/docs/guides-banners/telegram-miniapp-client.png"
  slug="/guides/telegram-miniapp-client"
/>

:::tip Live Demo

Before diving into development, experience Web3Auth in action! Check out our demo Telegram Mini App:

ðŸ‘‰ **[Launch Demo Mini App](https://t.me/w3a_tg_mini_app_bot)**

:::

:::info Source Code

You can find the full working code for this client + server example here:
[**Web3Auth Telegram Mini App Example**](https://github.com/Web3Auth/web3auth-pnp-examples/tree/main/other/ton-telegram-example)

:::

### **Objectives**

In this guide, we will focus on setting up the client-side of a Telegram Mini App using Web3Auth Web
SDK for authentication. By the end of this guide, you will:

1. Implement Web3Auth Web SDK in the **client-side app** to authenticate Telegram users using the
   JWT tokens generated in [Part 1](/guides/telegram-miniapp-server).
2. Retrieve wallet details (e.g., TON blockchain addresses) via Web3Auth and display them in the
   app.
3. Create a seamless user experience with automatic authentication flow.

:::tip

**Prerequisite**: If you haven't completed [Part 1](/guides/telegram-miniapp-server), where we set
up the backend server and handled Telegram authentication, it's recommended to start from there
before proceeding with this guide.

:::

---

### **Guide Breakdown**

1. **Part 1**: Set up the server-side logic to validate Telegram login data and generate JWT tokens.
2. **Part 2 (Current Guide)**: Focuses on integrating Web3Auth Web SDK into the client-side app to
   authenticate users and retrieve their wallet details.

---

### Overview

In this guide, we will implement the client-side part of the Telegram Mini App using Web3Auth Web
SDK. The client will handle user interaction, manage the login flow using Web3Auth's Web SDK, and
retrieve wallet details from the TON blockchain.

We'll be using the JWT token generated in [Part 1](/guides/telegram-miniapp-server) of this guide to
authenticate users on the client-side and establish a session with Web3Auth to retrieve
decentralized wallet information.

The flow is as follows:

<img
  style={{ display: "block", maxHeight: "800px", margin: "20px auto" }}
  src={TelegramMiniAppDiagram}
  alt="Telegram Mini App Flow Diagram"
/>

1. The user logs into the Telegram Mini App.
2. The JWT token (generated from the backend) is passed to Web3Auth Web SDK for authentication.
3. Web3Auth Web SDK authenticates the user and retrieves wallet details (e.g., the user's TON
   blockchain address).
4. The client displays the wallet details to the user.

---

### **What You Will Learn:**

1. Integrate Web3Auth Web SDK into a client-side app to handle user authentication.
2. Retrieve wallet details (TON blockchain) from Web3Auth.
3. Mock Telegram environments for local development and testing.
4. Create a modern, responsive UI for the Telegram Mini App.

---

[Follow these steps to set up your Custom Verifier with Web3Auth](/docs/authentication/custom-connections/custom-jwt#set-up-custom-jwt-connection).

---

### Step 1: Install Required Packages

Before starting, install the required dependencies for the client-side app.

```bash
npm install @web3auth/modal @telegram-apps/sdk-react tonweb @orbs-network/ton-access lucide-react
```

#### **Brief Overview of Dependencies:**

- **@web3auth/modal**: This is the core package for using Web3Auth's Web SDK, which provides a
  seamless authentication experience with a built-in UI modal for user login.
- **@telegram-apps/sdk-react**: This package is used to handle Telegram's launch parameters and mock
  Telegram environments for testing during development.
- **tonweb**: A JavaScript library for interacting with the TON blockchain, enabling wallet
  operations and transaction signing.
- **@orbs-network/ton-access**: Provides access to the TON blockchain RPC endpoint for fetching
  account information and signing messages on the TON network.
- **lucide-react**: A beautiful icon library for React applications, used for UI elements like copy
  buttons and theme toggles.

---

### Step 2: Set Up Environment Variables

Ensure that the `.env` file contains the following value:

```env
VITE_SERVER_URL=https://your-server-url.com
```

This value will be used to connect the client-side app to your backend server.

---

### Step 3: Import Necessary Packages and Set Up States

In this step, we will import all the necessary packages for our client-side application and set up
the states that will manage the login flow, user data, and TON blockchain interactions.

#### Import and State Setup

```tsx
import { useEffect, useState } from "react";
import {
  Web3Auth,
  WEB3AUTH_NETWORK,
  WALLET_CONNECTORS,
  AUTH_CONNECTION,
} from "@web3auth/modal";
import TonRPC from "./tonRpc";
import { useLaunchParams } from "@telegram-apps/sdk-react";
import { useTelegramMock } from "./hooks/useMockTelegramInitData";
import { Sun, Moon, Copy, Check } from "lucide-react";
import Loading from "./components/Loading";
import "./App.css";

const authConnectionId = "w3a-telegram-demo";
const clientId = "BPi5PB_UiIZ-cPz1GtV5i1I2iOSOHuimiXBI0e-Oe_u6X3oVAbCiAZOTEBtTXw4tsluTITPqA8zMsfxIKMjiqNQ";

function App() {
  const [isLoggingIn, setIsLoggingIn] = useState(false);
  const [web3Auth, setWeb3Auth] = useState<Web3Auth | null>(null);
  const [web3AuthInitialized, setWeb3AuthInitialized] = useState(false);
  const [userData, setUserData] = useState<any | null>(null);
  const [tonAccountAddress, setTonAccountAddress] = useState<string | null>(null);
  const [signedMessage, setSignedMessage] = useState<string | null>(null);
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  const [isDarkMode, setIsDarkMode] = useState(false);
  const [copiedStates, setCopiedStates] = useState<{ [key: string]: boolean }>({
    account: false,
    message: false,
  });

  const { initDataRaw, initData } = useLaunchParams() || {};

  useTelegramMock(); // Initialize the Telegram mock data
```

- **Explanation**: In this step, we import the necessary libraries and set up states like
  `isLoggingIn`, `web3Auth`, `web3AuthInitialized`, `userData`, `tonAccountAddress`, and
  `signedMessage` that will manage our app's flow. The Web3Auth Web SDK provides a streamlined
  approach for authentication and blockchain interactions.

---

### Step 4: Initialize Web3Auth Web SDK

Now that the states are set up, let's move on to initializing **Web3Auth Web SDK** and setting up
the connection to our backend server to fetch the ID token generated in
**[Part 1](/guides/telegram-miniapp-server)**.

#### Web3Auth Web SDK Initialization and Configuration

```tsx
useEffect(() => {
  const initializeWeb3Auth = async () => {
    try {
      const web3authInstance = new Web3Auth({
        clientId,
        web3AuthNetwork: WEB3AUTH_NETWORK.SAPPHIRE_MAINNET,
      });

      setWeb3Auth(web3authInstance);
      await web3authInstance.init();
      setWeb3AuthInitialized(true);
    } catch (error) {
      console.error("Error initializing Web3Auth:", error);
    }
  };

  initializeWeb3Auth();
}, []);
```

- **Explanation**: This block initializes Web3Auth using the **Web SDK**. The Web SDK provides a
  simplified initialization process, automatically handling chain configurations and provider setup.
  The Web SDK is designed to work seamlessly with various blockchain networks, including TON.

---

### Step 5: Mocking Telegram Environments for Local Development

Before we proceed with connecting to Web3Auth, we need to simulate the Telegram environment in local
development. We achieve this by using the `useTelegramMock()` hook.

#### Mocking Telegram Environment with `useTelegramMock.ts`

```tsx
/* eslint-disable camelcase */
import { mockTelegramEnv, parseInitData, retrieveLaunchParams } from "@telegram-apps/sdk-react";

/**
 * Mocks Telegram environment in development mode.
 */
export function useTelegramMock(): void {
  if (process.env.NODE_ENV !== "development") return;

  let shouldMock: boolean;

  try {
    retrieveLaunchParams();
    shouldMock = !!sessionStorage.getItem("____mocked");
  } catch (e) {
    shouldMock = true;
  }

  if (shouldMock) {
    const randomId = Math.floor(Math.random() * 1000000000);

    const initDataRaw = new URLSearchParams([
      [
        "user",
        JSON.stringify({
          id: randomId,
          first_name: "Andrew",
          last_name: "Rogue",
          username: "rogue",
          language_code: "en",
          is_premium: true,
          allows_write_to_pm: true,
        }),
      ],
      ["hash", "89d6079ad6762351f38c6dbbc41bb53048019256a9443988af7a48bcad16ba31"],
      ["auth_date", "1716922846"],
      ["start_param", "debug"],
      ["chat_type", "sender"],
      ["chat_instance", "8428209589180549439"],
    ]).toString();

    mockTelegramEnv({
      themeParams: {
        accentTextColor: "#6ab2f2",
        bgColor: "#17212b",
        buttonColor: "#5288c1",
        buttonTextColor: "#ffffff",
        destructiveTextColor: "#ec3942",
        headerBgColor: "#17212b",
        hintColor: "#708499",
        linkColor: "#6ab3f3",
        secondaryBgColor: "#232e3c",
        sectionBgColor: "#17212b",
        sectionHeaderTextColor: "#6ab3f3",
        subtitleTextColor: "#708499",
        textColor: "#f5f5f5",
      },
      initData: parseInitData(initDataRaw),
      initDataRaw,
      version: "7.7",
      platform: "tdesktop",
    });

    sessionStorage.setItem("____mocked", "1");
  }
}
```

- **Explanation**: This hook mocks the Telegram environment by generating mock `initData` that
  mimics Telegram's launch parameters, ensuring that the app behaves as if it were running in an
  actual Telegram Mini App environment.

:::tip **Why is Mocking Necessary?**

Mocking the environment during local development ensures smooth testing. Without mocking, the
Telegram SDK might throw errors or behave unexpectedly when not running within Telegram.

:::

---

### Step 6: Connecting to Web3Auth Web SDK and Fetching the ID Token

Now, let's connect to Web3Auth Web SDK and retrieve the ID token from our backend server, as
configured in **[Part 1](/guides/telegram-miniapp-server)**.

#### Connecting Web3Auth Web SDK

```tsx
useEffect(() => {
  const connectWeb3Auth = async () => {
    if (web3Auth && web3AuthInitialized && initDataRaw) {
      setIsLoggingIn(true);
      try {
        if (web3Auth.status === "connected") {
          await web3Auth.logout();
        }

        const idToken = await getIdTokenFromServer(initDataRaw, initData?.user.photoUrl);
        if (!idToken) return;

        await web3Auth.connectTo(WALLET_CONNECTORS.AUTH, {
          authConnectionId,
          authConnection: AUTH_CONNECTION.CUSTOM,
          idToken,
          extraLoginOptions: {
            isUserIdCaseSensitive: true,
          },
        });

        setIsLoggedIn(true);

        const tonRpc = new TonRPC(web3Auth.provider);
        const tonAddress = await tonRpc.getAccounts();
        setTonAccountAddress(tonAddress);

        const messageToSign = "Hello, TON!";
        const signedMsg = await tonRpc.signMessage(messageToSign);
        setSignedMessage(signedMsg);
      } catch (error) {
        console.error("Error during Web3Auth connection:", error);
      } finally {
        setIsLoggingIn(false);
      }
    }
  };

  if (web3AuthInitialized && initDataRaw) {
    connectWeb3Auth();
  }
}, [initDataRaw, web3Auth, web3AuthInitialized, initData?.user.photoUrl]);

useEffect(() => {
  if (initData?.user) {
    setUserData(initData.user);
  }
}, [initData]);

const getIdTokenFromServer = async (initDataRaw: string, photoUrl: string | undefined) => {
  const isMocked = !!sessionStorage.getItem("____mocked");
  const response = await fetch(`${import.meta.env.VITE_SERVER_URL}/auth/telegram`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ initDataRaw, isMocked, photoUrl }),
  });
  const data = await response.json();
  return data.token;
};
```

- **Explanation**: This effect establishes a connection to Web3Auth Web SDK using the ID token
  fetched from the backend. The Web SDK's `connectTo` method with `WALLET_CONNECTORS.AUTH` provides
  a streamlined way to authenticate users with custom JWT tokens. Once connected, we fetch the TON
  blockchain account details, including the account address and a signed message.

---

### Step 7: Create TON RPC Class for Blockchain Interactions

Create a `tonRpc.ts` file to handle TON blockchain interactions:

```tsx
import type { IProvider } from "@web3auth/modal";
import { getHttpEndpoint } from "@orbs-network/ton-access";
import TonWeb from "tonweb";

const rpc = await getHttpEndpoint();

export default class TonRPC {
  private provider: IProvider;
  private tonweb: TonWeb;

  constructor(provider: IProvider) {
    this.provider = provider;
    this.tonweb = new TonWeb(new TonWeb.HttpProvider(rpc));
  }

  async getAccounts(): Promise<string> {
    try {
      const privateKey = await this.getPrivateKey();
      const keyPair = this.getKeyPairFromPrivateKey(privateKey);
      const WalletClass = this.tonweb.wallet.all["v3R2"];
      const wallet = new WalletClass(this.tonweb.provider, {
        publicKey: keyPair.publicKey,
      });
      const address = await wallet.getAddress();
      return address.toString(true, true, true);
    } catch (error) {
      console.error("Error getting accounts:", error);
      return "";
    }
  }

  async signMessage(message: string): Promise<string> {
    try {
      const privateKey = await this.getPrivateKey();
      const keyPair = this.getKeyPairFromPrivateKey(privateKey);

      const messageBytes = new TextEncoder().encode(message);
      const signature = TonWeb.utils.nacl.sign.detached(messageBytes, keyPair.secretKey);

      return Buffer.from(signature).toString("hex");
    } catch (error) {
      console.error("Error signing message:", error);
      throw error;
    }
  }

  private getKeyPairFromPrivateKey(privateKey: string): {
    publicKey: Uint8Array;
    secretKey: Uint8Array;
  } {
    const privateKeyBytes = new Uint8Array(
      privateKey.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16)),
    );

    if (privateKeyBytes.length !== 32) {
      const adjustedPrivateKey = new Uint8Array(32);
      adjustedPrivateKey.set(privateKeyBytes.slice(0, 32));
      return TonWeb.utils.nacl.sign.keyPair.fromSeed(adjustedPrivateKey);
    }

    return TonWeb.utils.nacl.sign.keyPair.fromSeed(privateKeyBytes);
  }

  private async getPrivateKey(): Promise<string> {
    try {
      return await this.provider.request({
        method: "private_key",
      });
    } catch (error) {
      console.error("Error getting private key:", error);
      throw error;
    }
  }
}
```

---

### Step 8: Display User and TON Account Information

Finally, we display the user's Telegram profile details and their TON account address along with the
signed message in a modern, responsive UI:

```tsx
const copyToClipboard = async (text: string, type: "account" | "message") => {
  try {
    await navigator.clipboard.writeText(text);
    setCopiedStates((prev) => ({
      ...prev,
      [type]: true,
    }));

    // Reset the copied state after 2 seconds
    setTimeout(() => {
      setCopiedStates((prev) => ({
        ...prev,
        [type]: false,
      }));
    }, 2000);
  } catch (err) {
    console.error("Failed to copy text:", err);
  }
};

const toggleDarkMode = () => {
  setIsDarkMode(!isDarkMode);
};

return (
  <div className="container">
    <div className="header">
      <div className="logo-container">
        <img
          src={isDarkMode ? web3AuthLogoDark : web3AuthLogoLight}
          alt="Web3Auth Logo"
          className="web3auth-logo"
        />
        <button onClick={toggleDarkMode} className="theme-toggle" aria-label="Toggle dark mode">
          {isDarkMode ? <Sun className="text-yellow-500" /> : <Moon className="text-gray-700" />}
        </button>
      </div>
      <div className="title">
        <h4>Web3Auth Telegram MiniApp</h4>
      </div>
      <div className="description">
        <p>Seamless wallet access on any chain with Telegram. Just one click, and you're in!</p>
      </div>
    </div>

    {isLoggingIn ? (
      <Loading />
    ) : (
      <div className="grid">
        {isLoggedIn && (
          <>
            <div className="user-info-box">
              <img src={getFallbackAvatar(userData)} alt="User avatar" className="user-avatar" />
              <div className="user-info">
                <div className="id-with-logo">
                  <p>
                    <strong>ID:</strong> {userData?.id}
                  </p>
                  <img src={TelegramLogo} alt="Telegram Logo" className="telegram-logo" />
                </div>
                <p>
                  <strong>Username:</strong> {userData?.username}
                </p>
                <p>
                  <strong>Name:</strong> {userData?.firstName} {userData?.lastName || ""}
                </p>
              </div>
            </div>

            <div
              className="info-box"
              onClick={() => copyToClipboard(tonAccountAddress || "", "account")}
            >
              <div className="info-box-content">
                <p>
                  <strong>TON Account:</strong>
                  <span className="ellipsed-text">{tonAccountAddress}</span>
                </p>
                {copiedStates.account ? (
                  <Check className="copy-icon success" size={18} />
                ) : (
                  <Copy className="copy-icon" size={18} />
                )}
              </div>
            </div>

            <div
              className="info-box"
              onClick={() => copyToClipboard(signedMessage || "", "message")}
            >
              <div className="info-box-content">
                <p>
                  <strong>Signed Message:</strong>
                  <span className="ellipsed-text">{signedMessage}</span>
                </p>
                {copiedStates.message ? (
                  <Check className="copy-icon success" size={18} />
                ) : (
                  <Copy className="copy-icon" size={18} />
                )}
              </div>
            </div>
          </>
        )}
      </div>
    )}

    <footer className="footer">
      <a
        href="https://web3auth.io/community/t/build-powerful-telegram-mini-apps-with-web3auth/9244"
        target="_blank"
        rel="noopener noreferrer"
        className="learn-more-button"
      >
        Telegram MiniApp Setup Guide
      </a>
    </footer>
  </div>
);
```

---

### Step 9: Running and Testing the App

To run the app locally:

```bash
npm run start
```

Ensure that the backend server from **[Part 1](/guides/telegram-miniapp-server)** is running and
accessible via the `VITE_SERVER_URL`.

For detailed steps on debugging your Telegram Mini App, refer to this
[official guide](https://docs.ton.org/develop/dapps/telegram-apps/testing-apps).

---

### Step 10: Deploy Your App

Deploy this app to GitHub Pages, Vercel, or any other hosting service. For Vercel:

- Push your code to GitHub.
- Sign in to [Vercel](https://vercel.com/).
- Import your GitHub repository.
- Deploy your project.

After deployment, you will get a domain link. Use this link when setting up your Telegram bot.

:::info

Remember to whitelist the deployed client app's URL in the allowed origins array in the backend
server CORS configuration that we set up in **[Part 1](/guides/telegram-miniapp-server)**.

:::

---

### Step 11: Setting Up a Telegram Bot

To connect your Mini App to Telegram, you need to **create a bot** and set up a Mini App for it.

Follow these steps:

1. **Start a Chat with BotFather**

   - Open the Telegram app or web version.
   - Search for `@BotFather` or follow the [link](https://t.me/BotFather).
   - Start a chat with BotFather by clicking on the `START` button.

2. **Create a New Bot**

   - Send the `/newbot` command to BotFather.
   - BotFather will ask you to choose a name for your bot (this is a display name and can contain
     spaces).
   - Next, choose a unique username for your bot, which must end in "bot" (e.g., `sample_bot`).

3. **Set Up Bot Mini App**

   - Send the `/mybots` command to BotFather.
   - Choose your bot from the list and select the "Bot Settings" option.
   - Choose the "Menu Button" option.
   - Choose "Edit Menu Button URL" and send the URL to your Telegram Mini App, for example, the link
     from GitHub Pages or Vercel deploy.

4. **Accessing the Bot**
   - You can now search for your bot using its username in Telegram's search bar.
   - Press the button next to the attach picker to launch your Telegram Mini App in the messenger.

---

### Key Features of Web3Auth Web SDK Implementation

The Web3Auth Web SDK provides several advantages for Telegram Mini App development:

1. **Simplified Integration**: The Web SDK reduces boilerplate code and provides a streamlined
   authentication flow.

2. **Flexible Authentication**: The Web SDK supports multiple authentication methods, including
   custom JWT authentication for seamless Telegram integration.

3. **Automatic Chain Configuration**: The SDK automatically handles blockchain configurations,
   making it easier to work with different networks like TON.

4. **Enhanced Security**: The Web SDK includes additional security features and best practices out
   of the box.

5. **Better Error Handling**: Improved error handling and user feedback mechanisms.

---

This completes the client-side setup for the Telegram Mini App using Web3Auth Web SDK. By following
these steps, you can authenticate Telegram users, retrieve their TON blockchain account details, and
provide a seamless user experience with modern UI components and automatic authentication flow.
