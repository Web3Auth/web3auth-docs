---
title: Usage
hide_table_of_contents: false
displayed_sidebar: apiReference
---

import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";

---

Once you've installed and successfully initialized tKey and a service provider, you can use it to authenticate your users and generate their tKey
share. Further, you can use a variety of functions exposed by the tKey SDK, its modules and the service provider itself to manage different aspects of
your users' authentication needs.

Natively, the instance of `ThresholdKey` _(referred to as `tkey` in our examples)_ returns the following functions:

<Tabs
  defaultValue="table"
  values={[
    { label: "Table", value: "table" },
    { label: "Class Reference", value: "class" },
  ]}
>

<TabItem value="table">

</TabItem>

<TabItem value="class">

```ts
// ALL UNDERSCORES DONT NEED
class ThresholdKey implements ITKey {
  modules: ModuleMap;
  enableLogging: boolean;
  serviceProvider: IServiceProvider;
  storageLayer: IStorageLayer;
  shares: ShareStorePolyIDShareIndexMap;
  privKey: BN;
  lastFetchedCloudMetadata: Metadata;
  metadata: Metadata;
  manualSync: boolean;
  _localMetadataTransitions: LocalMetadataTransitions;
  _refreshMiddleware: RefreshMiddlewareMap;
  _reconstructKeyMiddleware: ReconstructKeyMiddlewareMap;
  _shareSerializationMiddleware: ShareSerializationMiddleware;
  storeDeviceShare: (deviceShareStore: ShareStore, customDeviceInfo?: StringifiedType) => Promise<void>; // Call to trigger module to store shares
  {/* haveWriteMetadataLock: string;  */}
  constructor(args?: TKeyArgs);
  static fromJSON(value: StringifiedType, args: TKeyArgs): Promise<ThresholdKey>;
  getStorageLayer(): IStorageLayer;
  {/* getMetadata(): IMetadata; */}
  initialize(params?: {
    withShare?: ShareStore;
    importKey?: BN;
    neverInitializeNewKey?: boolean;
    transitionMetadata?: Metadata;
    previouslyFetchedCloudMetadata?: Metadata;
    previousLocalMetadataTransitions?: LocalMetadataTransitions;
    delete1OutOf1?: boolean;
  }): Promise<KeyDetails>;
  /**
   * catchupToLatestShare recursively loops fetches metadata of the provided share and checks if there is an encrypted share for it.
   * @param shareStore - share to start of with
   * @param polyID - if specified, polyID to refresh to if it exists
   */
  {/* catchupToLatestShare(params: {
    shareStore: ShareStore;
    polyID?: PolynomialID;
    includeLocalMetadataTransitions?: boolean;
  }): Promise<CatchupToLatestShareResult>; */}
  reconstructKey(_reconstructKeyMiddleware?: boolean): Promise<ReconstructedKeyResult>;
  {/* reconstructLatestPoly(): Polynomial; */}
  deleteShare(shareIndex: BNString): Promise<DeleteShareResult>;
  generateNewShare(): Promise<GenerateNewShareResult>;
  _refreshShares(threshold: number, newShareIndexes: Array<string>, previousPolyID: PolynomialID): Promise<RefreshSharesResult>;
  _initializeNewKey({
    determinedShare,
    initializeModules,
    importedKey,
    delete1OutOf1,
  }?: {
    determinedShare?: BN;
    initializeModules?: boolean;
    importedKey?: BN;
    delete1OutOf1?: boolean;
  }): Promise<InitializeNewKeyResult>;
  {/* addLocalMetadataTransitions(params: {
    input: LocalTransitionData;
    serviceProvider?: IServiceProvider;
    privKey?: Array<BN>;
    acquireLock?: boolean;
  }): Promise<void>; */} // I THINK
  syncLocalMetadataTransitions(): Promise<void>;
  {/* updateSDK(params?: { withShare?: ShareStore }): Promise<ThresholdKey>; */}
  {/* inputShareStore(shareStore: ShareStore): void; */}
  inputShareStoreSafe(shareStore: ShareStore, autoUpdateMetadata?: boolean): Promise<void>;
  outputShareStore(shareIndex: BNString, polyID?: string): ShareStore;
  _setKey(privKey: BN): void;
  {/* getCurrentShareIndexes(): string[]; */}
  getKeyDetails(): KeyDetails;
  {/* generateAuthMetadata(params: { input: Metadata[] }): AuthMetadata[]; */}
  {/* setAuthMetadata(params: { input: Metadata; serviceProvider?: IServiceProvider; privKey?: BN }): Promise<{
    message: string;
  }>; */}
  {/* setAuthMetadataBulk(params: { input: Metadata[]; serviceProvider?: IServiceProvider; privKey?: BN[] }): Promise<void>;
  getAuthMetadata(params: { serviceProvider?: IServiceProvider; privKey?: BN; includeLocalMetadataTransitions?: boolean }): Promise<Metadata>; */}
  {/* getGenericMetadataWithTransitionStates(params: {
    fromJSONConstructor: FromJSONConstructor;
    serviceProvider?: IServiceProvider;
    privKey?: BN;
    includeLocalMetadataTransitions?: boolean;
    _localMetadataTransitions?: LocalMetadataTransitions;
  }): Promise<unknown>; */}
  {/* acquireWriteMetadataLock(): Promise<number>;
  releaseWriteMetadataLock(): Promise<void>;
  _syncShareMetadata(adjustScopedStore?: (ss: unknown) => unknown): Promise<void>;
  syncMultipleShareMetadata(shares: Array<BN>, adjustScopedStore?: (ss: unknown) => unknown): Promise<void>;
  _addRefreshMiddleware(
    moduleName: string,
    middleware: (generalStore: unknown, oldShareStores: ShareStoreMap, newShareStores: ShareStoreMap) => unknown
  ): void;
  _addReconstructKeyMiddleware(moduleName: string, middleware: () => Promise<Array<BN>>): void;
  _addShareSerializationMiddleware(
    serialize: (share: BN, type: string) => Promise<unknown>,
    deserialize: (serializedShare: unknown, type: string) => Promise<BN>
  ): void;
  _setDeviceStorage(storeDeviceStorage: (deviceShareStore: ShareStore) => Promise<void>): void; */}
  addShareDescription(shareIndex: string, description: string, updateMetadata?: boolean): Promise<void>;
  deleteShareDescription(shareIndex: string, description: string, updateMetadata?: boolean): Promise<void>;
  updateShareDescription(shareIndex: string, oldDescription: string, newDescription: string, updateMetadata?: boolean): Promise<void>;
  {/* encrypt(data: Buffer): Promise<EncryptedMessage>;
  decrypt(encryptedMessage: EncryptedMessage): Promise<Buffer>;
  _setTKeyStoreItem(moduleName: string, data: TkeyStoreItemType): Promise<void>;
  _deleteTKeyStoreItem(moduleName: string, id: string): Promise<void>; */}
  getTKeyStore(moduleName: string): Promise<TkeyStoreItemType[]>;
  getTKeyStoreItem(moduleName: string, id: string): Promise<TkeyStoreItemType>;
  outputShare(shareIndex: BNString, type?: string): Promise<unknown>;
  inputShare(share: unknown, type?: string): Promise<void>;
  toJSON(): StringifiedType;
  getApi(): ITKeyApi;
  private setModuleReferences;
  private initializeModules;
}
```

</TabItem>

</Tabs>
