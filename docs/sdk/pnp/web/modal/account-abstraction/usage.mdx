---
title: Usage
sidebar_label: Usage
description: "@web3auth/modal Native Account Abstraction | Documentation - Web3Auth"
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

import ConfigureSigners from "@site/src/common/sdk/pnp/web/_configure-aa-signers.mdx";
import SmartAccountAddress from "@site/src/common/sdk/pnp/web/_aa-address.mdx";
import SmartAccountSendTransaction from "@site/src/common/sdk/pnp/web/_aa-send-transaction.mdx";

// TODO: Add section that Wagmi doesn't require any configuration for signer.

### Configure Signer

<ConfigureSigners />

## Smart Account Address

<SmartAccountAddress />

## Send Transaction

<SmartAccountSendTransaction />

## Sign transaction

Developers have the option to sign a transaction without immediately sending it. If it is the user's
first transaction, the `UserOperation` calldata will automatically include the required deployment
data to create the user's Smart Account on-chain.

:::info

Wagmi doesn't have hooks for signing transactions yet.

:::

<Tabs
  defaultValue="viem"
  values={[
    { label: "Viem", value: "viem" },
    { label: "Ethers", value: "ethers" },
  ]}
>

<TabItem value="ethers">

```tsx
// Convert 1 ether to WEI format
const amount = parseEther("1");

const signature = await signer.signTransaction({
  to: "DESTINATION_ADDRESS",
  value: amount,
});
```

</TabItem>
<TabItem value="viem">

```tsx
// Convert 1 ether to WEI format
const amount = parseEther("1");
const addresses = await walletClient.getAddresses();

const request = await walletClient.prepareTransactionRequest({
  account: addresses[0],
  to: "DESTINATION_ADDRESS",
  value: amount,
});

const signature = await walletClient.signTransaction(request as any);
```

</TabItem>
</Tabs>

## Sign Message

Message signing is also supported with Smart Accounts; however, the signature and verification
process differs from that of Externally Owned Accounts (EOAs). Smart Accounts adhere to the EIP-1271
standard for signature verification, utilizing the isValidSignature method defined in the smart
contract wallet, rather than relying on the ecrecover function used by EOAs.

[Learn more about EIP 1271](https://eips.ethereum.org/EIPS/eip-1271).

<Tabs
  defaultValue="viem"
  values={[
    { label: "Viem", value: "viem" },
    { label: "Ethers", value: "ethers" },
    { label: "Wagmi", value: "wagmi" },
  ]}
>

<TabItem value="wagmi">

```tsx
import { useSignMessage } from "wagmi";
const { data: signature, signMessage } = useSignMessage();

const message = "YOUR_MESSAGE";

signMessage({ message });

// Use signature as needed
```

</TabItem>
<TabItem value="ethers">

```tsx
const originalMessage = "YOUR_MESSAGE";

// Sign the message
const signedMessage = await signer.signMessage(originalMessage);
```

</TabItem>
<TabItem value="viem">

```tsx
const originalMessage = "YOUR_MESSAGE";

const addresses = await walletClient.getAddresses();

const signedMessage = await walletClient.signMessage({
  account: address[0],
  message: originalMessage,
});
```

</TabItem>
</Tabs>

## Send Batch Transaction

One of the key features of Smart Accounts is the ability to perform batch transactions.
Traditionally, if a user wants to swap Token A for Token B, they must first approve Token A and then
execute the swap in a separate transaction. With batch transaction support in Smart Accounts, both
steps can be combined into a single UserOperation.

Executing a batch transaction differs slightly from the standard transaction flow. To perform it,
developers must use the `BundlerClient` provided by Web3Auth. The default Web3Auth provider instance
cannot be used for this purpose, as it is a proxy designed to work seamlessly with common signer
libraries for basic operations.

When calling `sendUserOperation`, it returns a UserOperation hash, which is the keccak256 hash of
the entire user operation, not the transaction hash. To retrieve the final transaction details,
developers must use the `waitForUserOperationReceipt` method. This function waits for the
UserOperation to be included in a block and returns a complete receipt, including the entryPoint,
blockNumber, blockHash, and the actual transactionHash.

```ts
// Use your Web3Auth instance
const accountAbstractionProvider = web3auth.accountAbstractionProvider;
// Use the same accountAbstractionProvider we created earlier.
const bundlerClient = accountAbstractionProvider.bundlerClient!;
const smartAccount = accountAbstractionProvider.smartAccount!;

// 0.00001 ETH in WEI format
const amount = 10000000000000n;

const userOpHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "DESTINATION_ADDRESS",
      value: amount,
      data: "0x",
    },
    {
      to: "DESTINATION_ADDRESS",
      value: amount,
      data: "0x",
    },
  ],
});

// Retrieve user operation receipt
const receipt = await bundlerClient.waitForUserOperationReceipt({
  hash: userOpHash,
});

const transactionHash = receipt.receipt.transactionHash;
```

## Send transaction using ERC-20 Paymaster

To submit a transaction using an ERC-20 paymaster, the associated ERC-20 token must first be
approved for use by the paymaster. Ideally, the application should first check the existing token
allowance and only initiate an approval transaction if the allowance is insufficient.

Modifying the token allowance requires a write operation on the ERC-20 token contract. In the
example below, Pimlico is used as the paymaster, but developers should update the paymaster and
ERC-20 token addresses to match their specific implementation. To use an ERC-20 paymaster, refer to
the configuration guide for
[ERC-20 paymaster context.](/docs/sdk/pnp/web/modal/account-abstraction/configure/sdk).

```ts
// Use your Web3Auth instance
const accountAbstractionProvider = web3auth.accountAbstractionProvider;

// Use the same accountAbstractionProvider we created earlier.
const bundlerClient = accountAbstractionProvider.bundlerClient!;
const smartAccount = accountAbstractionProvider.smartAccount!;

// Pimlico's ERC-20 Paymaster address
const pimlicoPaymasterAddress = "0x0000000000000039cd5e8aE05257CE51C473ddd1";

// USDC address on Ethereum Sepolia
const usdcAddress = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238";

// 0.00001 ETH in WEI format
const amount = 10000000000000n;

// 10 USDC in WEI format. Since USDC has 6 decimals, 10 * 10^6
const approvalAmount = 10000000n;

const userOpHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    // Approve USDC on Sepolia chain for Pimlico's ERC 20 Paymaster
    {
      to: usdcAddress,
      abi: parseAbi(["function approve(address,uint)"]),
      functionName: "approve",
      args: [pimlicoPaymasterAddress, approvalAmount],
    },
    {
      to: "DESTINATION_ADDRESS",
      value: amount,
      data: "0x",
    },
    {
      to: "DESTINATION_ADDRESS",
      value: amount,
      data: "0x",
    },
  ],
});

// Retrieve user operation receipt
const receipt = await bundlerClient.waitForUserOperationReceipt({
  hash: userOpHash,
});

const transactionHash = receipt.receipt.transactionHash;
```
